name: CD - Deploy to Development

on:
  workflow_run:
    workflows: ["CI - Build and Push to ECR"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

env:
  ECR_REPOSITORY: frontend-demo
  ECR_REGISTRY: ${{ vars.AWS_DEV_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_DEV_ECR_REGION }}.amazonaws.com
  INSTANCE_ID: i-09f9fe068a9daefed
  SERVICE_NAME: frontend
  SSH_USER: ubuntu

jobs:
  deploy:
    name: Deploy to Development
    runs-on: ubuntu-latest
    
    # Only run if CI workflow was successful and triggered by push (not PR)
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'push'
    
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEV_GITHUB_ACTION_ROLE }}
          aws-region: ${{ vars.AWS_DEV_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get latest image tag
        id: get-tag
        run: |
          SHORT_SHA=$(echo ${{ github.event.workflow_run.head_sha }} | cut -c1-7)
          MAIN_SHA_TAG="main-${SHORT_SHA}"
          echo "image_tag=${MAIN_SHA_TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${ECR_REGISTRY}/${ECR_REPOSITORY}:${MAIN_SHA_TAG}" >> $GITHUB_OUTPUT

      - name: Get EC2 instance details
        id: get-instance
        run: |
          PRIVATE_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ env.INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0].PrivateIpAddress' \
            --output text \
            --region ${{ vars.AWS_DEV_REGION }})
          echo "private_ip=${PRIVATE_IP}" >> $GITHUB_OUTPUT

      - name: Verify image exists in ECR
        run: |
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=${{ steps.get-tag.outputs.image_tag }} \
            --region ${{ vars.AWS_DEV_ECR_REGION }}

      - name: Copy deployment template to EC2
        run: |
          # Get API key from SSM Parameter Store
          API_KEY=$(aws ssm get-parameter --name "/inference/api-key" --with-decryption --query 'Parameter.Value' --output text --region ${{ vars.AWS_DEV_REGION }})
          
          # Read template and replace placeholders
          TEMPLATE_CONTENT=$(cat deployment/frontend.service.template)
          TEMPLATE_CONTENT="${TEMPLATE_CONTENT//\{\{IMAGE\}\}/${{ steps.get-tag.outputs.full_image }}}"
          TEMPLATE_CONTENT="${TEMPLATE_CONTENT//\{\{ECR_REGISTRY\}\}/${{ env.ECR_REGISTRY }}}"
          TEMPLATE_CONTENT="${TEMPLATE_CONTENT//\{\{ECR_REGION\}\}/${{ vars.AWS_DEV_ECR_REGION }}}"
          TEMPLATE_CONTENT="${TEMPLATE_CONTENT//\{\{API_KEY\}\}/$API_KEY}"
          
          # Create the service file on EC2 via SSM
          aws ssm send-command \
            --instance-ids ${{ env.INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"echo '$TEMPLATE_CONTENT' | sudo tee /etc/systemd/system/${{ env.SERVICE_NAME }}.service > /dev/null\"]" \
            --region ${{ vars.AWS_DEV_REGION }}

      - name: Stop existing service
        run: |
          aws ssm send-command \
            --instance-ids ${{ env.INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["if systemctl list-units --full -all | grep -Fq \"${{ env.SERVICE_NAME }}.service\"; then echo \"Service ${{ env.SERVICE_NAME }} exists, stopping it...\"; sudo systemctl stop ${{ env.SERVICE_NAME }} || true; sudo systemctl disable ${{ env.SERVICE_NAME }} || true; else echo \"Service ${{ env.SERVICE_NAME }} does not exist, skipping stop step\"; fi"]' \
            --region ${{ vars.AWS_DEV_REGION }}

      - name: Update and reload service
        run: |
          aws ssm send-command \
            --instance-ids ${{ env.INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["echo \"Updating ${{ env.SERVICE_NAME }} service...\"; sudo docker stop ${{ env.SERVICE_NAME }} || true; sudo docker rm ${{ env.SERVICE_NAME }} || true; sudo systemctl daemon-reload"]' \
            --region ${{ vars.AWS_DEV_REGION }}

      - name: Start service
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["echo \"Starting ${{ env.SERVICE_NAME }} service...\"; sudo systemctl enable ${{ env.SERVICE_NAME }}; sudo systemctl start ${{ env.SERVICE_NAME }}; sleep 5; sudo systemctl status ${{ env.SERVICE_NAME }} --no-pager"]' \
            --region ${{ vars.AWS_DEV_REGION }} \
            --query 'Command.CommandId' \
            --output text)
          
          # Wait for command to complete
          aws ssm wait command-executed \
            --command-id $COMMAND_ID \
            --instance-id ${{ env.INSTANCE_ID }} \
            --region ${{ vars.AWS_DEV_REGION }}

      - name: Wait for service to be ready
        run: sleep 30

      - name: Health check via SSM
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ env.INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["curl -f http://localhost:8080 || exit 1"]' \
            --region ${{ vars.AWS_DEV_REGION }} \
            --query 'Command.CommandId' \
            --output text)
          
          # Wait for health check to complete
          aws ssm wait command-executed \
            --command-id $COMMAND_ID \
            --instance-id ${{ env.INSTANCE_ID }} \
            --region ${{ vars.AWS_DEV_REGION }}
          
          # Get command status
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ env.INSTANCE_ID }} \
            --region ${{ vars.AWS_DEV_REGION }} \
            --query 'Status' \
            --output text)
          
          if [ "$STATUS" != "Success" ]; then
            echo "Health check failed"
            exit 1
          fi
          
          echo "Health check passed"

      - name: Deployment summary
        run: |
          echo "### ðŸš€ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** development" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ steps.get-tag.outputs.full_image }}" >> $GITHUB_STEP_SUMMARY
          echo "**SHA:** ${{ github.event.workflow_run.head_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health Check:** âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service URL:** http://${{ steps.get-instance.outputs.private_ip }}:8080" >> $GITHUB_STEP_SUMMARY